<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="ExDoc v0.34.0"/><meta name="project" content="Phoenix v1.7.14"/><title>Phoenix.Socket.Transport â€” Phoenix v1.7.14</title><link rel="stylesheet" href="dist/html-elixir-K5ICTFVY.css"/><script src="dist/handlebars.runtime-NWIB6V2M.js"></script><script src="dist/handlebars.templates-K7URE6B4.js"></script><script src="dist/sidebar_items-E091C2AA.js"></script><script src="docs_config.js"></script><script async="async" src="dist/html-Q4PYR6ZR.js"></script></head><body data-type="modules" class="page-behaviour sidebar-closed"><script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script><div class="body-wrapper"><nav id="sidebar" class="sidebar"><div class="sidebar-header"><div class="sidebar-projectInfo"><a href="https://www.phoenixframework.org" class="sidebar-projectImage"><img src="assets/logo.png" alt="Phoenix"/></a><div><a href="https://www.phoenixframework.org" class="sidebar-projectName" translate="no">
Phoenix
        </a><div class="sidebar-projectVersion" translate="no">
          v1.7.14
        </div></div></div><ul id="sidebar-listNav" class="sidebar-listNav" role="tablist"><li></li><li></li><li></li></ul></div><div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button"><ul id="extras-full-list" class="full-list"></ul></div><div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden="hidden"><ul id="modules-full-list" class="full-list"></ul></div><div id="tasks-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="tasks-list-tab-button" hidden="hidden"><ul id="tasks-full-list" class="full-list"></ul></div></nav><main class="content"><output role="status" id="toast"></output><div id="content" class="content-inner"><div class="top-search"><div class="search-settings"><form class="search-bar" action="search.html"><label class="search-label"><span class="sr-only">Search documentation of Phoenix</span><input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/></label></form><div class="autocomplete"></div></div></div><div id="top-content"><h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L1" title="View Source" class="icon-action" rel="help"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a><span translate="no">Phoenix.Socket.Transport</span><small>behaviour</small><small class="app-vsn" translate="no">(Phoenix v1.7.14)</small></h1><section id="moduledoc"><p>Outlines the Socket <-> Transport communication.</p><p>Each transport, such as websockets and longpolling, must interact
with a socket. This module defines said behaviour.</p><p><a href="Phoenix.Socket.html"><code class="inline">Phoenix.Socket</code></a> is just one possible implementation of a socket
that multiplexes events over multiple channels. If you implement
this behaviour, then a transport can directly invoke your
implementation, without passing through channels.</p><p>This module also provides convenience functions for implementing
transports.</p><h2 id="module-example" class="section-heading"><a href="#module-example" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Example</span></h2><p>Here is a simple echo socket implementation:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"></span><span class="nc">EchoSocket</span><span class="w"></span><span class="k" data-group-id="7047440730-1">do</span><span class="w"></span><span class="na">@behaviour</span><span class="w"></span><span class="nc">Phoenix.Socket.Transport</span><span class="w"></span><span class="kd">def</span><span class="w"></span><span class="nf">child_spec</span><span class="p" data-group-id="7047440730-2">(</span><span class="n">opts</span><span class="p" data-group-id="7047440730-2">)</span><span class="w"></span><span class="k" data-group-id="7047440730-3">do</span><span class="w"></span><span class="c1"># We won't spawn any process, so let's ignore the child spec</span><span class="w"></span><span class="ss">:ignore</span><span class="w"></span><span class="k" data-group-id="7047440730-3">end</span><span class="w"></span><span class="kd">def</span><span class="w"></span><span class="nf">connect</span><span class="p" data-group-id="7047440730-4">(</span><span class="n">state</span><span class="p" data-group-id="7047440730-4">)</span><span class="w"></span><span class="k" data-group-id="7047440730-5">do</span><span class="w"></span><span class="c1"># Callback to retrieve relevant data from the connection.</span><span class="w"></span><span class="c1"># The map contains options, params, transport and endpoint keys.</span><span class="w"></span><span class="p" data-group-id="7047440730-6">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"></span><span class="n">state</span><span class="p" data-group-id="7047440730-6">}</span><span class="w"></span><span class="k" data-group-id="7047440730-5">end</span><span class="w"></span><span class="kd">def</span><span class="w"></span><span class="nf">init</span><span class="p" data-group-id="7047440730-7">(</span><span class="n">state</span><span class="p" data-group-id="7047440730-7">)</span><span class="w"></span><span class="k" data-group-id="7047440730-8">do</span><span class="w"></span><span class="c1"># Now we are effectively inside the process that maintains the socket.</span><span class="w"></span><span class="p" data-group-id="7047440730-9">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"></span><span class="n">state</span><span class="p" data-group-id="7047440730-9">}</span><span class="w"></span><span class="k" data-group-id="7047440730-8">end</span><span class="w"></span><span class="kd">def</span><span class="w"></span><span class="nf">handle_in</span><span class="p" data-group-id="7047440730-10">(</span><span class="p" data-group-id="7047440730-11">{</span><span class="n">text</span><span class="p">,</span><span class="w"></span><span class="c">_opts</span><span class="p" data-group-id="7047440730-11">}</span><span class="p">,</span><span class="w"></span><span class="n">state</span><span class="p" data-group-id="7047440730-10">)</span><span class="w"></span><span class="k" data-group-id="7047440730-12">do</span><span class="w"></span><span class="p" data-group-id="7047440730-13">{</span><span class="ss">:reply</span><span class="p">,</span><span class="w"></span><span class="ss">:ok</span><span class="p">,</span><span class="w"></span><span class="p" data-group-id="7047440730-14">{</span><span class="ss">:text</span><span class="p">,</span><span class="w"></span><span class="n">text</span><span class="p" data-group-id="7047440730-14">}</span><span class="p">,</span><span class="w"></span><span class="n">state</span><span class="p" data-group-id="7047440730-13">}</span><span class="w"></span><span class="k" data-group-id="7047440730-12">end</span><span class="w"></span><span class="kd">def</span><span class="w"></span><span class="nf">handle_info</span><span class="p" data-group-id="7047440730-15">(</span><span class="bp">_</span><span class="p">,</span><span class="w"></span><span class="n">state</span><span class="p" data-group-id="7047440730-15">)</span><span class="w"></span><span class="k" data-group-id="7047440730-16">do</span><span class="w"></span><span class="p" data-group-id="7047440730-17">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"></span><span class="n">state</span><span class="p" data-group-id="7047440730-17">}</span><span class="w"></span><span class="k" data-group-id="7047440730-16">end</span><span class="w"></span><span class="kd">def</span><span class="w"></span><span class="nf">terminate</span><span class="p" data-group-id="7047440730-18">(</span><span class="c">_reason</span><span class="p">,</span><span class="w"></span><span class="c">_state</span><span class="p" data-group-id="7047440730-18">)</span><span class="w"></span><span class="k" data-group-id="7047440730-19">do</span><span class="w"></span><span class="ss">:ok</span><span class="w"></span><span class="k" data-group-id="7047440730-19">end</span><span class="w"></span><span class="k" data-group-id="7047440730-1">end</span></code></pre><p>It can be mounted in your endpoint like any other socket:</p><pre><code class="makeup elixir" translate="no"><span class="n">socket</span><span class="w"></span><span class="s">"/socket"</span><span class="p">,</span><span class="w"></span><span class="nc">EchoSocket</span><span class="p">,</span><span class="w"></span><span class="ss">websocket</span><span class="p">:</span><span class="w"></span><span class="no">true</span><span class="p">,</span><span class="w"></span><span class="ss">longpoll</span><span class="p">:</span><span class="w"></span><span class="no">true</span></code></pre><p>You can now interact with the socket under <code class="inline">/socket/websocket</code>
and <code class="inline">/socket/longpoll</code>.</p><h2 id="module-custom-transports" class="section-heading"><a href="#module-custom-transports" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Custom transports</span></h2><p>Sockets are operated by a transport. When a transport is defined,
it usually receives a socket module and the module will be invoked
when certain events happen at the transport level.</p><p>Whenever the transport receives a new connection, it should invoke
the <a href="#c:connect/1"><code class="inline">connect/1</code></a> callback with a map of metadata. Different sockets
may require different metadata.</p><p>If the connection is accepted, the transport can move the connection
to another process, if so desires, or keep using the same process. The
process responsible for managing the socket should then call <a href="#c:init/1"><code class="inline">init/1</code></a>.</p><p>For each message received from the client, the transport must call
<a href="#c:handle_in/2"><code class="inline">handle_in/2</code></a> on the socket. For each informational message the
transport receives, it should call <a href="#c:handle_info/2"><code class="inline">handle_info/2</code></a> on the socket.</p><p>Transports can optionally implement <a href="#c:handle_control/2"><code class="inline">handle_control/2</code></a> for handling
control frames such as <code class="inline">:ping</code> and <code class="inline">:pong</code>.</p><p>On termination, <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> must be called. A special atom with
reason <code class="inline">:closed</code> can be used to specify that the client terminated
the connection.</p><h2 id="module-booting" class="section-heading"><a href="#module-booting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Booting</span></h2><p>Whenever your endpoint starts, it will automatically invoke the
<code class="inline">child_spec/1</code> on each listed socket and start that specification
under the endpoint supervisor.</p><p>Since the socket supervision tree is started by the endpoint,
any custom transport must be started after the endpoint in a
supervision tree.</p></section></div><section id="summary" class="details-list"><h1 class="section-heading"><a class="hover-link" href="#summary"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Summary</span></h1><div class="summary-types summary"><h2><a href="#types">Types</a></h2><div class="summary-row"><div class="summary-signature"><a href="#t:state/0" data-no-tooltip="data-no-tooltip" translate="no">state()</a></div></div></div><div class="summary-callbacks summary"><h2><a href="#callbacks">Callbacks</a></h2><div class="summary-row"><div class="summary-signature"><a href="#c:child_spec/1" data-no-tooltip="data-no-tooltip" translate="no">child_spec(keyword)</a></div><div class="summary-synopsis"><p>Returns a child specification for socket management.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:connect/1" data-no-tooltip="data-no-tooltip" translate="no">connect(transport_info)</a></div><div class="summary-synopsis"><p>Connects to the socket.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:drainer_spec/1" data-no-tooltip="data-no-tooltip" translate="no">drainer_spec(keyword)</a></div><div class="summary-synopsis"><p>Returns a child specification for terminating the socket.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:handle_control/2" data-no-tooltip="data-no-tooltip" translate="no">handle_control({}, state)</a></div><div class="summary-synopsis"><p>Handles incoming control frames.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:handle_in/2" data-no-tooltip="data-no-tooltip" translate="no">handle_in({}, state)</a></div><div class="summary-synopsis"><p>Handles incoming socket messages.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:handle_info/2" data-no-tooltip="data-no-tooltip" translate="no">handle_info(message, state)</a></div><div class="summary-synopsis"><p>Handles info messages.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:init/1" data-no-tooltip="data-no-tooltip" translate="no">init(state)</a></div><div class="summary-synopsis"><p>Initializes the socket state.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#c:terminate/2" data-no-tooltip="data-no-tooltip" translate="no">terminate(reason, state)</a></div><div class="summary-synopsis"><p>Invoked on termination.</p></div></div></div><div class="summary-functions summary"><h2><a href="#functions">Functions</a></h2><div class="summary-row"><div class="summary-signature"><a href="#check_origin/5" data-no-tooltip="data-no-tooltip" translate="no">check_origin(conn, handler, endpoint, opts, sender \\ &Plug.Conn.send_resp/1)</a></div><div class="summary-synopsis"><p>Checks the origin request header against the list of allowed origins.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#check_subprotocols/2" data-no-tooltip="data-no-tooltip" translate="no">check_subprotocols(conn, subprotocols)</a></div><div class="summary-synopsis"><p>Checks the Websocket subprotocols request header against the allowed subprotocols.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#code_reload/3" data-no-tooltip="data-no-tooltip" translate="no">code_reload(conn, endpoint, opts)</a></div><div class="summary-synopsis"><p>Runs the code reloader if enabled.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#connect_info/3" data-no-tooltip="data-no-tooltip" translate="no">connect_info(conn, endpoint, keys)</a></div><div class="summary-synopsis"><p>Extracts connection information from <code class="inline">conn</code> and returns a map.</p></div></div><div class="summary-row"><div class="summary-signature"><a href="#transport_log/2" data-no-tooltip="data-no-tooltip" translate="no">transport_log(conn, level)</a></div><div class="summary-synopsis"><p>Logs the transport request.</p></div></div></div></section><section id="types" class="details-list"><h1 class="section-heading"><a class="hover-link" href="#types"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Types</span></h1><div class="types-list"><section class="detail" id="t:state/0"><div class="detail-header"><a href="#t:state/0" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this type"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this type</span></a><h1 class="signature" translate="no">state()</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L95" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@type</span> state() :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()</pre></div></section></section></div></section><section id="callbacks" class="details-list"><h1 class="section-heading"><a class="hover-link" href="#callbacks"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Callbacks</span></h1><div class="callbacks-list"><section class="detail" id="c:child_spec/1"><div class="detail-header"><a href="#c:child_spec/1" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">child_spec(keyword)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L121" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> child_spec(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">keyword</a>()) :: <a href="https://www.erlang.org/doc/apps/stdlib/supervisor.html#t:child_spec/0">:supervisor.child_spec</a>() | :ignore</pre></div><p>Returns a child specification for socket management.</p><p>This is invoked only once per socket regardless of
the number of transports and should be responsible
for setting up any process structure used exclusively
by the socket regardless of transports.</p><p>Each socket connection is started by the transport
and the process that controls the socket likely
belongs to the transport. However, some sockets spawn
new processes, such as <a href="Phoenix.Socket.html"><code class="inline">Phoenix.Socket</code></a> which spawns
channels, and this gives the ability to start a
supervision tree associated to the socket.</p><p>It receives the socket options from the endpoint,
for example:</p><pre><code class="makeup elixir" translate="no"><span class="n">socket</span><span class="w"></span><span class="s">"/my_app"</span><span class="p">,</span><span class="w"></span><span class="nc">MyApp.Socket</span><span class="p">,</span><span class="w"></span><span class="ss">shutdown</span><span class="p">:</span><span class="w"></span><span class="mi">5000</span></code></pre><p>means <code class="inline">child_spec([shutdown: 5000])</code> will be invoked.</p><p><code class="inline">:ignore</code> means no child spec is necessary for this socket.</p></section></section><section class="detail" id="c:connect/1"><div class="detail-header"><a href="#c:connect/1" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">connect(transport_info)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L162" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> connect(transport_info :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) :: {:ok, <a href="#t:state/0">state</a>()} | {:error, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()} | :error</pre></div><p>Connects to the socket.</p><p>The transport passes a map of metadata and the socket
returns <code class="inline">{:ok, state}</code>, <code class="inline">{:error, reason}</code> or <code class="inline">:error</code>.
The state must be stored by the transport and returned
in all future operations. When <code class="inline">{:error, reason}</code> is
returned, some transports - such as WebSockets - allow
customizing the response based on <code class="inline">reason</code> via a custom
<code class="inline">:error_handler</code>.</p><p>This function is used for authorization purposes and it
may be invoked outside of the process that effectively
runs the socket.</p><p>In the default <a href="Phoenix.Socket.html"><code class="inline">Phoenix.Socket</code></a> implementation, the
metadata expects the following keys:</p><ul><li><code class="inline">:endpoint</code> - the application endpoint</li><li><code class="inline">:transport</code> - the transport name</li><li><code class="inline">:params</code> - the connection parameters</li><li><code class="inline">:options</code> - a keyword list of transport options, often
given by developers when configuring the transport.
It must include a <code class="inline">:serializer</code> field with the list of
serializers and their requirements</li></ul></section></section><section class="detail" id="c:drainer_spec/1"><div class="detail-header"><a href="#c:drainer_spec/1" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">drainer_spec(keyword)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L133" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a><span class="note">(optional)</span></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> drainer_spec(<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">keyword</a>()) :: <a href="https://www.erlang.org/doc/apps/stdlib/supervisor.html#t:child_spec/0">:supervisor.child_spec</a>() | :ignore</pre></div><p>Returns a child specification for terminating the socket.</p><p>This is a process that is started late in the supervision
tree with the specific goal of draining connections on
application shutdown.</p><p>Similar to <code class="inline">child_spec/1</code>, it receives the socket options
from the endpoint.</p></section></section><section class="detail" id="c:handle_control/2"><div class="detail-header"><a href="#c:handle_control/2" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">handle_control({}, state)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L210" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a><span class="note">(optional)</span></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> handle_control(
  {message :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), opts :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">keyword</a>()},
  <a href="#t:state/0">state</a>()
) ::
  {:ok, <a href="#t:state/0">state</a>()}
  | {:reply, :ok | :error, {opcode :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(), message :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}, <a href="#t:state/0">state</a>()}
  | {:stop, reason :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), <a href="#t:state/0">state</a>()}</pre></div><p>Handles incoming control frames.</p><p>The message is represented as <code class="inline">{payload, options}</code>. It must
return one of:</p><ul><li><code class="inline">{:ok, state}</code> - continues the socket with no reply</li><li><code class="inline">{:reply, status, reply, state}</code> - continues the socket with reply</li><li><code class="inline">{:stop, reason, state}</code> - stops the socket</li></ul><p>Control frames only supported when using websockets.</p><p>The <code class="inline">options</code> contains an <code class="inline">opcode</code> key, this will be either <code class="inline">:ping</code> or
<code class="inline">:pong</code>.</p><p>If a control frame doesn't have a payload, then the payload value
will be <code class="inline">nil</code>.</p></section></section><section class="detail" id="c:handle_in/2"><div class="detail-header"><a href="#c:handle_in/2" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">handle_in({}, state)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L187" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> handle_in(
  {message :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), opts :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">keyword</a>()},
  <a href="#t:state/0">state</a>()
) ::
  {:ok, <a href="#t:state/0">state</a>()}
  | {:reply, :ok | :error, {opcode :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(), message :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}, <a href="#t:state/0">state</a>()}
  | {:stop, reason :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), <a href="#t:state/0">state</a>()}</pre></div><p>Handles incoming socket messages.</p><p>The message is represented as <code class="inline">{payload, options}</code>. It must
return one of:</p><ul><li><code class="inline">{:ok, state}</code> - continues the socket with no reply</li><li><code class="inline">{:reply, status, reply, state}</code> - continues the socket with reply</li><li><code class="inline">{:stop, reason, state}</code> - stops the socket</li></ul><p>The <code class="inline">reply</code> is a tuple contain an <code class="inline">opcode</code> atom and a message that can
be any term. The built-in websocket transport supports both <code class="inline">:text</code> and
<code class="inline">:binary</code> opcode and the message must be always iodata. Long polling only
supports text opcode.</p></section></section><section class="detail" id="c:handle_info/2"><div class="detail-header"><a href="#c:handle_info/2" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">handle_info(message, state)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L229" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> handle_info(message :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), <a href="#t:state/0">state</a>()) ::
  {:ok, <a href="#t:state/0">state</a>()}
  | {:push, {opcode :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(), message :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()}, <a href="#t:state/0">state</a>()}
  | {:stop, reason :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), <a href="#t:state/0">state</a>()}</pre></div><p>Handles info messages.</p><p>The message is a term. It must return one of:</p><ul><li><code class="inline">{:ok, state}</code> - continues the socket with no reply</li><li><code class="inline">{:push, reply, state}</code> - continues the socket with reply</li><li><code class="inline">{:stop, reason, state}</code> - stops the socket</li></ul><p>The <code class="inline">reply</code> is a tuple contain an <code class="inline">opcode</code> atom and a message that can
be any term. The built-in websocket transport supports both <code class="inline">:text</code> and
<code class="inline">:binary</code> opcode and the message must be always iodata. Long polling only
supports text opcode.</p></section></section><section class="detail" id="c:init/1"><div class="detail-header"><a href="#c:init/1" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">init(state)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L170" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> init(<a href="#t:state/0">state</a>()) :: {:ok, <a href="#t:state/0">state</a>()}</pre></div><p>Initializes the socket state.</p><p>This must be executed from the process that will effectively
operate the socket.</p></section></section><section class="detail" id="c:terminate/2"><div class="detail-header"><a href="#c:terminate/2" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this callback"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this callback</span></a><h1 class="signature" translate="no">terminate(reason, state)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L241" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><div class="specs"><pre translate="no"><span class="attribute">@callback</span> terminate(reason :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(), <a href="#t:state/0">state</a>()) :: :ok</pre></div><p>Invoked on termination.</p><p>If <code class="inline">reason</code> is <code class="inline">:closed</code>, it means the client closed the socket. This is
considered a <code class="inline">:normal</code> exit signal, so linked process will not automatically
exit. See <a href="https://hexdocs.pm/elixir/Process.html#exit/2"><code class="inline">Process.exit/2</code></a> for more details on exit signals.</p></section></section></div></section><section id="functions" class="details-list"><h1 class="section-heading"><a class="hover-link" href="#functions"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Functions</span></h1><div class="functions-list"><section class="detail" id="check_origin/5"><span id="check_origin/4"></span><div class="detail-header"><a href="#check_origin/5" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this function"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this function</span></a><h1 class="signature" translate="no">check_origin(conn, handler, endpoint, opts, sender \\ &Plug.Conn.send_resp/1)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L326" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><p>Checks the origin request header against the list of allowed origins.</p><p>Should be called by transports before connecting when appropriate.
If the origin header matches the allowed origins, no origin header was
sent or no origin was configured, it will return the given connection.</p><p>Otherwise a 403 Forbidden response will be sent and the connection halted.
It is a noop if the connection has been halted.</p></section></section><section class="detail" id="check_subprotocols/2"><div class="detail-header"><a href="#check_subprotocols/2" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this function"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this function</span></a><h1 class="signature" translate="no">check_subprotocols(conn, subprotocols)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L385" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><p>Checks the Websocket subprotocols request header against the allowed subprotocols.</p><p>Should be called by transports before connecting when appropriate.
If the sec-websocket-protocol header matches the allowed subprotocols,
it will put sec-websocket-protocol response header and return the given connection.
If no sec-websocket-protocol header was sent it will return the given connection.</p><p>Otherwise a 403 Forbidden response will be sent and the connection halted.
It is a noop if the connection has been halted.</p></section></section><section class="detail" id="code_reload/3"><div class="detail-header"><a href="#code_reload/3" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this function"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this function</span></a><h1 class="signature" translate="no">code_reload(conn, endpoint, opts)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L295" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><p>Runs the code reloader if enabled.</p></section></section><section class="detail" id="connect_info/3"><div class="detail-header"><a href="#connect_info/3" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this function"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this function</span></a><h1 class="signature" translate="no">connect_info(conn, endpoint, keys)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L462" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><p>Extracts connection information from <code class="inline">conn</code> and returns a map.</p><p>Keys are retrieved from the optional transport option <code class="inline">:connect_info</code>.
This functionality is transport specific. Please refer to your transports'
documentation for more information.</p><p>The supported keys are:</p><ul><li><p><code class="inline">:peer_data</code> - the result of <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#get_peer_data/1"><code class="inline">Plug.Conn.get_peer_data/1</code></a></p></li><li><p><code class="inline">:trace_context_headers</code> - a list of all trace context headers</p></li><li><p><code class="inline">:x_headers</code> - a list of all request headers that have an "x-" prefix</p></li><li><p><code class="inline">:uri</code> - a <code class="inline">%URI{}</code> derived from the conn</p></li><li><p><code class="inline">:user_agent</code> - the value of the "user-agent" request header</p></li></ul></section></section><section class="detail" id="transport_log/2"><div class="detail-header"><a href="#transport_log/2" class="detail-link" data-no-tooltip="data-no-tooltip" title="Link to this function"><i class="ri-link-m" aria-hidden="true"></i><span class="sr-only">Link to this function</span></a><h1 class="signature" translate="no">transport_log(conn, level)</h1><a href="https://github.com/phoenixframework/phoenix/blob/v1.7.14/lib/phoenix/socket/transport.ex#L308" class="icon-action" rel="help" title="View Source"><i class="ri-code-s-slash-line" aria-hidden="true"></i><span class="sr-only">View Source</span></a></div><section class="docstring"><p>Logs the transport request.</p><p>Available for transports that generate a connection.</p></section></section></div></section><footer class="footer"><p><span class="line"><a href="https://hex.pm/packages/phoenix/1.7.14" class="footer-hex-package">Hex Package</a><a href="https://preview.hex.pm/preview/phoenix/1.7.14">Hex Preview</a></span><span class="line"><a href="Phoenix.epub" title="ePub version">
              Download ePub version
            </a></span></p><p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.0) for the

          <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a></p></footer></div></main></div></body></html>